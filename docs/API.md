<!--

ATTENTION:

********************************************************************************

DO NOT EDIT THIS FILE DIRECTLY.

It is automatically generated by jsdoc2md. None of
manual changes to this file will be accepted. See the package.json `scripts` for
the command to generate this document.

********************************************************************************

-->
## Modules

<dl>
<dt><a href="#module_utils">utils</a></dt>
<dd><p>utilities for working with koa-router</p>
</dd>
</dl>

## Classes

<dl>
<dt><a href="#Route">Route</a></dt>
<dd></dd>
<dt><a href="#Router">Router</a></dt>
<dd><p>The Router object provides the API for mapping paths to functions and composing routers.
Use it to declare your routes, add middleware, and map requests to handler functions.</p>
</dd>
</dl>

<a name="module_utils"></a>

## utils
utilities for working with koa-router

<a name="module_utils.inspect"></a>

### utils.inspect(router) ⇒ <code>string</code>
toString utility to turn a router into a tree-like diagram of its current
stack and composition. Useful for debugging the current state of a router.

**Kind**: static method of [<code>utils</code>](#module_utils)  
**Returns**: <code>string</code> - the router tree representation as a string  

| Param | Type | Description |
| --- | --- | --- |
| router | <code>router</code> | the router to inspect |

**Example**  
```js
const router = new Router();
const usersRouter = new Router();

router.get('root', '/', () => {});
usersRouter.get('user', '/users/:id', () => {});
usersRouter.param('id', (id, ctx, next) => {});

router.use(() => {});
router.nest(usersRouter);

console.log(inspect(router));
// outputs:
// * Router
// ├── middleware
// │   ├── anonymous
// │   └── paramHandler(id)
// ├── routes
// │   ├──     GET  /           root        /^(?:\/(?=$))?$/i
// │   └──     GET  /users/:id  user        /^\/users\/((?:[^\/]+?))(?:\/(?=$))?$/i
// └── nested
//     * Router
//     ├── middleware
//     │   └── paramHandler(id)
//     ├── routes
//     │   └──     GET  /users/:id  user        /^\/users\/((?:[^\/]+?))(?:\/(?=$))?$/i
//     └── nested
```
<a name="Route"></a>

## Route
**Kind**: global class  

* [Route](#Route)
    * [new Route(options)](#new_Route_new)
    * [.path](#Route+path) : <code>string</code>
    * [.name](#Route+name) : <code>string</code>
    * [.toPathWithParams(...params)](#Route+toPathWithParams)

<a name="new_Route_new"></a>

### new Route(options)
create a route object


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| options | <code>object</code> | <code>{}</code> |  |
| options.method | <code>string</code> |  | uppercase HTTP method for which this route handles (or '*') |
| options.path | <code>string</code> |  | the path that this route handles                                    (will be given to path-to-regexp) |
| options.handler | <code>function</code> |  | the function that handles this route |
| [options.name] | <code>string</code> |  | the name of this route |
| [options.prefix] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | the prefix for this route |
| [options.strict] | <code>boolean</code> | <code>false</code> | when set to `true`, this route will **not** match                                             paths with a trailing slash `/` |
| [options.sensitive] | <code>boolean</code> | <code>false</code> | whether matching is performed case sensitively |

<a name="Route+path"></a>

### route.path : <code>string</code>
the path this route matches

**Kind**: instance property of [<code>Route</code>](#Route)  
<a name="Route+name"></a>

### route.name : <code>string</code>
name of this route

**Kind**: instance property of [<code>Route</code>](#Route)  
<a name="Route+toPathWithParams"></a>

### route.toPathWithParams(...params)
returns a path built with the provided params (if any)

**Kind**: instance method of [<code>Route</code>](#Route)  

| Param | Type | Description |
| --- | --- | --- |
| ...params | <code>params</code> | the positional params to interpolate into the path                            in order of appearance |

<a name="Router"></a>

## Router
The Router object provides the API for mapping paths to functions and composing routers.
Use it to declare your routes, add middleware, and map requests to handler functions.

**Kind**: global class  

* [Router](#Router)
    * [new Router([options])](#new_Router_new)
    * _instance_
        * [.name](#Router+name) : <code>string</code>
        * [.prefix](#Router+prefix) ⇒ <code>string</code>
        * [.prefix=](#Router+prefix=) ⇒ <code>string</code>
        * [.get|head|options|patch|post|put|delete|all](#Router+get|head|options|patch|post|put|delete|all) ⇒ [<code>Router</code>](#Router)
        * [.use(...functions)](#Router+use) ⇒ [<code>Router</code>](#Router)
        * [.nest([prefix], child)](#Router+nest) ⇒ [<code>Router</code>](#Router)
        * [.param(name, handler)](#Router+param) ⇒ [<code>Router</code>](#Router)
        * [.path(name, ...args)](#Router+path) ⇒ <code>string</code>
        * [.routes(options)](#Router+routes) ⇒ <code>function</code>
        * [.redirect(fromPath, toPathOrName, [code])](#Router+redirect) ⇒ [<code>Router</code>](#Router)
    * _static_
        * [.path(path, ...args)](#Router.path) ⇒ <code>string</code>

<a name="new_Router_new"></a>

### new Router([options])
Create a new router.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [options] | <code>object</code> |  |  |
| [options.prefix] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | the string to prefix all routes                                     declared for this router with |
| [options.name] | <code>string</code> |  | the name of the router—used for debugging                                and log lines |
| [options.strict] | <code>boolean</code> | <code>false</code> | whether or not a trailing slash is                                         is required for routes |
| [options.sensitive] | <code>boolean</code> | <code>false</code> | whether the routes should be case                                            sensitive or not |

**Example**  
```js
const router = new Router();
```

with options.prefix and options.name

```js
const router = new Router({ prefix: '/admin', name: 'admin-router' });
```
<a name="Router+name"></a>

### router.name : <code>string</code>
the name of the router (provided during construction)

**Kind**: instance property of [<code>Router</code>](#Router)  
**Read only**: true  
<a name="Router+prefix"></a>

### router.prefix ⇒ <code>string</code>
getter for the router prefix

**Kind**: instance property of [<code>Router</code>](#Router)  
**Returns**: <code>string</code> - the prefix  
**Read only**: true  
<a name="Router+prefix="></a>

### router.prefix= ⇒ <code>string</code>
setter for the router prefix

**Kind**: instance property of [<code>Router</code>](#Router)  
**Returns**: <code>string</code> - the prefix  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [path] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | the prefix to set |

<a name="Router+get|head|options|patch|post|put|delete|all"></a>

### router.get|head|options|patch|post|put|delete|all ⇒ [<code>Router</code>](#Router)
adds a route to the router for the HTTP method matching this method name

**Kind**: instance property of [<code>Router</code>](#Router)  
**Returns**: [<code>Router</code>](#Router) - self  

| Param | Type | Description |
| --- | --- | --- |
| [name] | <code>string</code> | the name of the route |
| path | <code>string</code> | the path that this route will handle |
| ...functions | <code>function</code> | middleware functions that will be composed                                and invoked when this route is matched in                                a request cycle |

**Example**  
Add a GET handler for a path like /

```js
const router = new Router();
router.get('/', (ctx, next) => {
  // handle a `GET /` request
});
```

Add a POST handler for a path like /purchase

```js
const router = new Router();
router.post('/purchase', (ctx, next) => {
  // handle a `POST /purchase` request
});
```

Add a DELETE handler for a path like /photos/3

```js
const router = new Router();
router.delete('/photos/:id', (ctx, next) => {
  // handle a `DELETE /photos/1` request
});
```

```js
const router = new Router();
router.all('/_health', (ctx, next) => {
  // handle a `{any HTTP method} /_health` request
});
```

etc...

Full list of supported methods:
acl, bind, checkout, connect, copy, delete, get, head, link, lock,
m-search, merge, mkactivity, mkcalendar, mkcol, move, notify, options,
patch, post, propfind, proppatch, purge, put, rebind, report, search,
subscribe, trace, unbind, unlink, unlock, unsubscribe

Aliases:

Router#* -> Router#all

Router#del -> Router#del
<a name="Router+use"></a>

### router.use(...functions) ⇒ [<code>Router</code>](#Router)
[use description]

**Kind**: instance method of [<code>Router</code>](#Router)  
**Returns**: [<code>Router</code>](#Router) - self  

| Param | Type | Description |
| --- | --- | --- |
| ...functions | <code>function</code> | middleware functions to add to the middleware stack                           for this router |

<a name="Router+nest"></a>

### router.nest([prefix], child) ⇒ [<code>Router</code>](#Router)
nests a router in another router [optionally with a prefix]

This is used for nesting when one router (parent) nests another (child) at
a specific path. In order to not modify the child router, we create a
surrogate router with the intended prefix. The child router is nested
within this surrogate, and then the surrogate is nested within the parent.
That way, the child router is not modified (no prefix added) and thus
can be continued to be used in other contexts (nested again somewhere else)

All middleware, param handlers, and routes will be added to the parent router
in order of declaration at the time of mounting. Modifying the child after
it has been nested will affect the routes nested within the parent.

**Kind**: instance method of [<code>Router</code>](#Router)  
**Returns**: [<code>Router</code>](#Router) - self  

| Param | Type | Description |
| --- | --- | --- |
| [prefix] | <code>string</code> | the prefix to add to the nested router's routes |
| child | [<code>Router</code>](#Router) | the router to nest within this router |

**Example**  
```js
const router = new Router();
const v1Router = new Router();
const v2Router = new Router();
const healthRouter = new Router();

healthRouter
  .use((ctx, next) => {
    // A
    return next();
  })
  .get('/_health', (ctx, next) => {
    // B
  });

router.get('/version', () => {
  // C
});

v1Router.post('/post', () => {
  // D
});

v2Router
  .use((ctx, next) => {
    // E
  })
  .post('/post', () => {
    // F
  });

router.nest(healthRouter);
router.nest('/v1', v1Router);
router.nest('/v2', v2Router);

// The router state:

* Router
├── middleware
│   ├── anonymous
│   └── anonymous
├── routes
│   ├──     GET  /version            /^\/version(?:\/(?=$))?$/i
│   ├──     GET  /_health            /^\/_health(?:\/(?=$))?$/i
│   ├──    POST  /v1/post            /^\/v1\/post(?:\/(?=$))?$/i
│   └──    POST  /v2/post            /^\/v2\/post(?:\/(?=$))?$/i
└── nested
    * Router
    ├── middleware
    │   └── anonymous
    ├── routes
    │   └──     GET  /_health            /^\/_health(?:\/(?=$))?$/i
    └── nested
    * /v1 prefix
    └── nested
        * Router
        ├── middleware
        ├── routes
        │   └──    POST  /post         /^\/post(?:\/(?=$))?$/i
        └── nested
    * /v2 prefix
    └── nested
        * Router
        ├── middleware
        │   └── anonymous
        ├── routes
        │   └──    POST  /post         /^\/post(?:\/(?=$))?$/i
        └── nested
```
<a name="Router+param"></a>

### router.param(name, handler) ⇒ [<code>Router</code>](#Router)
adds a middleware function to be called whenever a param with the provided name is found in
the request path. This is useful for loading a record from the database or validation on
path parameters before the request reaches the route handler.

**Kind**: instance method of [<code>Router</code>](#Router)  
**Returns**: [<code>Router</code>](#Router) - the router  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>String</code> | the name of the path parameter the provided function handles |
| handler | <code>function</code> | the function to call when the named parameter is captured                            in a request path |

**Example**  
```js
const postsRouter = new Router();

postsRouter.get('/posts/:id/comments', () => {});

postsRouter.param('id', async (id, ctx, next) => {
  // find a post in the database when `id` appears in the matched path
  ctx.state.post = await Post.find(id);
});
```

In the example above, a request to `/posts/1/comments` will trigger the
param middleware and call `Post.find(1)`.

Param handlers are added to the middleware stack of a router in the order they are
defined. They are executed in the order they are defined.
<a name="Router+path"></a>

### router.path(name, ...args) ⇒ <code>string</code>
build a path for a route found by the name provided

**Kind**: instance method of [<code>Router</code>](#Router)  
**Returns**: <code>string</code> - the path with interpolated params and query string if necessary  
**Throws**:

- Error


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | the route name to build a path for |
| ...args | <code>\*</code> | forwarded to [toPathWithParams](#Route+toPathWithParams) |

**Example**  
Generate a path with params as an object:

```js
router.get('user-photos', '/users/:id/photos/:category', () => {});

router.path('user-photos', { id: 1, category: 'me' });
// => '/users/1/photos/me'
```

Generate a path with path params as positional arguments:

```js
router.get('user-photos', '/users/:id/photos/:category', () => {});

router.path('user-photos', 1, 'me');
// => '/users/1/photos/me'
```
<a name="Router+routes"></a>

### router.routes(options) ⇒ <code>function</code>
creates a middleware function to mount on a koa2 application that handles
dispatching to routes:

**Kind**: instance method of [<code>Router</code>](#Router)  
**Returns**: <code>function</code> - router middleware function that handles dispatching and invocation  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| options | <code>object</code> |  |  |
| [options.allowedMethods] | <code>boolean</code> \| <code>string</code> | <code>false</code> | add allowedMethods and notImplemented                                                 middleware to the returned routing function                                                 when `true`, the middleware is added and                                                 405, 501, and OPTIONS responses are handled                                                 for you. When `'throw'`, 405 and 501 responses                                                 are handled by throwing an error |
| [options.methodNotAllowed] | <code>function</code> |  | a function that returns an error to be thrown                                              when a 405 should be returned to the client                                              note: allowedMethods must be set to 'throw' |
| [options.notImplemented] | <code>function</code> |  | a function that returns an error to be thrown                                            when a 501 should be returned to the client                                            note: allowedMethods must be set to 'throw' |

**Example**  
Mount routes on a koa application:

```js
const app = new Koa();
const router = new Router();

router.get('/', (ctx) => ctx.body = 'Hello World');

app.use(router.routes());

app.listen(3000);
```

Mount routes on a koa application with MethodNotAllowed and NotImplemented middleware:

```js
const app = new Koa();
const router = new Router();

router.get('/', (ctx) => ctx.body = 'Hello World');

app.use(router.routes({ allowedMethods: true }));

app.listen(3000);
```

Mount routes on a koa application with MethodNotAllowed and NotImplemented middleware
that throws a custom error (with [Boom](https://github.com/hapijs/boom)) when necessary:

```js
const app = new Koa();
const router = new Router();
const Boom = require('boom');

router.get('/', (ctx) => ctx.body = 'Hello World');

app.use(router.routes({
  allowedMethods: 'throw',
  notImplemented: () => new Boom.notImplemented(),
  methodNotAllowed: () => new Boom.methodNotAllowed(),
}));

app.listen(3000);
```
<a name="Router+redirect"></a>

### router.redirect(fromPath, toPathOrName, [code]) ⇒ [<code>Router</code>](#Router)
adds a redirect middleware to redirect requests to fromPath to
the toPath or route found by the toName argument with optional status code
override

**Kind**: instance method of [<code>Router</code>](#Router)  
**Returns**: [<code>Router</code>](#Router) - the router (self)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| fromPath | <code>string</code> |  | path that should be redirected |
| toPathOrName | <code>string</code> |  | path or name of the route to be redirected to |
| [code] | <code>number</code> | <code>301</code> | the status code to use for this redirect |

**Example**  
```js
const router = new Router();
router.redirect('/deals/123', '/deals/456');
// => redirects requests to /deals/123 to /deals/456 with status 301
```

```js
const router = new Router();
router.get('new-deal', '/deals/new', () => {});
router.redirect('/deals/123', 'new-deal');
// => redirects requests to /deals/123 to /deals/new with status 301
```

```js
const router = new Router();
router.redirect('/vote', '/countdown', 302);
// => redirects requests to /vote to /countdown with status 302 (temporary)
```
<a name="Router.path"></a>

### Router.path(path, ...args) ⇒ <code>string</code>
generates a path with interpolated path parameters

**Kind**: static method of [<code>Router</code>](#Router)  
**Returns**: <code>string</code> - the path with interpolated params and query string if necessary  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | the path to interpolate path params in |
| ...args | <code>\*</code> | forwarded to [toPathWithParams](#Route+toPathWithParams) |

**Example**  
Generate a path with an object of path params:

```js
Router.path('/users/:id', { id: 1 });
// => '/users/1'
```

Generate a path with path params as positional arguments:

```js
Router.path('/users/:id', 1);
// => '/users/1'
```
